///////////////////////////////////////////////////////////////////////////////
//
//	DataRAM.cpp
//
///////////////////////////////////////////////////////////////////////////////
#include "DataRAM.h"

///////////////////////////////////////////////////////////////////////////////
//
//	Constructeur
//
///////////////////////////////////////////////////////////////////////////////
DataRAM::DataRAM( sc_module_name zName, const char *zDataFileName, unsigned long ulRAMSize, bool bVerbose )
:RAM(zName, zDataFileName, ulRAMSize, bVerbose)
{
}


///////////////////////////////////////////////////////////////////////////////
//
//	Destructeur
//
///////////////////////////////////////////////////////////////////////////////
DataRAM::~DataRAM()
{
}


///////////////////////////////////////////////////////////////////////////////
//
//	Read
//
///////////////////////////////////////////////////////////////////////////////
unsigned int DataRAM::Read(unsigned int uiAddr)
{
	// On appele la classe parent
	return RAM::Read(uiAddr);
}

	
///////////////////////////////////////////////////////////////////////////////
//
//	Write
//
///////////////////////////////////////////////////////////////////////////////
void DataRAM::Write(unsigned int uiAddr, unsigned int uiData)
{	

	if ( uiAddr >= m_ulRAMSize )
	{
		cout << "Ecriture hors de la plage de la RAM" << endl;
		
		// Fin de la simulation
		sc_stop();
	}
	else
	{		
		// On copie le contenu de la mÃ©moire
		memcpy( (void*)((long)(m_ptrRAM) + uiAddr), &uiData, 4);
	}
}
